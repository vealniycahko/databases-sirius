Используемая база данных:

```sql
drop table if exists tour, review cascade;

create table tour
(
    name       text primary key,
    duration   int,
    start_date date,
    price      decimal
);

insert into tour
values ('Вся Карелия', 8, '09-20-2022', 40560),
       ('Старая Русса', 5, '09-21-2022', 54123),
       ('Хиты Золотого кольца', 5, '09-22-2022', 45104),
       ('По Великому Шелковому пути', 5, '09-22-2022', 40272),
       ('Столицы и замки Беларуси', 8, '09-22-2022', 34271),
       ('Города мастеров', 6, '09-22-2022', 31315),
       ('Сокровища Селигера', 7, '09-23-2022', 38705),
       ('По берегам живописной Мсты', 9, '09-23-2022', 48193),
       ('Легенды и тайны Байкала', 5, '09-23-2022', 49664),
       ('Огни Босфора', 7, '09-23-2022', 41082),
       ('Три дня на Волге', 7, '09-24-2022', 59828),
       ('Семь чудес страны души', 9, '09-26-2022', 32485);

create table review
(
    id        int generated always as identity primary key,
    tour_name text references tour,
    comment   text,
    score     int
);

insert into review (tour_name, comment, score)
values ('Столицы и замки Беларуси', 'Не очень.', 3),
       ('Столицы и замки Беларуси', 'Супер!', 5),
       ('Сокровища Селигера', 'Пойдёт.', 4);
```

Результаты SQL-запросов можно материализовать в базе данных для
последующего быстрого их получения, например:

```sql
create
materialized view tour_with_reviews as
select *
from tour t
         join review r on t.name = r.tour_name;
```

Запрос к материализованному представлению:

```sql
select *
from tour_with_reviews;
```

Если мы добавим строки в одну из таблиц, то увидим, что содержимое
материализованного представления не поменяется:

```sql
insert into review (tour_name, comment, score)
values ('Сокровища Селигера', 'Не понравилось!', 2);

select *
from tour_with_reviews;
```

Для того чтобы представление обновилось нужно выполнить refresh -
либо через триггер изменения таблиц, из которых строится представление,
либо по таймеру через cron. Так же для того чтобы refresh не блокировал
чтение из представления нужно задать уникальный индекс

```sql
drop index if exists tour_with_reviews_id;

-- добавление уникального индекса:
create unique index tour_with_reviews_id on tour_with_reviews (tour_name, id);
```

```sql
-- обновление представления:
refresh
materialized view concurrently tour_with_reviews;
```

### Использование индексов для ускорения запросов:

#### hash индекс

Представляет собой hash таблицу, по которой происходит
поиск в случае фильтрации через знак равенства, сложность поиска в
таком случае будет O(1).

Например, можно задать hash индекс для продолжительности тура:

```sql
drop index if exists tour_duration;
create index tour_duration on tour using hash(duration);

select *
from tour
where duration = 5;
```

hash индекс нельзя строить по комбинации столбцов, такой код выдаст
ошибку при выполнении:

```sql
create index tour_start_duration on tour using hash (start_date, duration);
```

#### b-tree индекс

Используется когда нужен поиск по значениям нескольких столбцов, а так же
когда нужно использовать все операторы сравнения `<`, `<=`, `=`, `>=`, `>`

В простейшем представлении представляет собой отсортированные в
указанном порядке указатели на строки таблицы, вместе со значениями,
по которым происходит сортировка:

```sql
drop index if exists tour_search_by_date_duration_price;
create index tour_search_by_date_duration_price on tour
    using btree (start_date, duration, price);

-- примерное содержание индекса:
select start_date, duration, price, row_number() over () as row_number
from tour
order by (start_date, duration, price);

-- пример запроса по индексу:
select name, start_date, duration, price
from tour
where start_date >= '09-22-2022'
  and start_date <= '09-23-2022'
  and duration >= 5
  and duration <= 7
  and price < 45000;
```

Сложность поиска для первого указанного столбца будет log(N), для
последующих - зависит от того, образуются ли группы при сортировке.
В данном случае в таблице есть несколько строк для каждой даты,
соответственно для каждой даты будет происходить сортировка по
продолжительности. И для каждой даты поиск продолжительности будет log(N).

Более того, в данном примере есть повторяющиеся пары дата/продолжительность
для которых будет произведена сортировка по цене.

**Другой пример:**

```sql
drop table if exists dialog cascade;

create table dialog
(
    id       int generated always as identity primary key,
    started  timestamp,
    finished timestamp
);

insert into dialog (started, finished)
values ('2022-09-07 14:27:21.715866', '2022-09-07 14:37:21.455829'),
       ('2022-09-07 14:28:12.129169', '2022-09-07 14:57:39.318868'),
       ('2022-09-07 14:28:54.17272', '2022-09-07 14:31:20.874919'),
       ('2022-09-07 14:28:54.181464', '2022-09-07 14:50:11.740188'),
       ('2022-09-07 14:29:33.423314', '2022-09-07 14:49:53.328792');

drop index if exists dialog_finished_started;
create index dialog_finished_started
    on dialog using btree (finished, started);

-- примерное содержание индекса:
select finished, started, row_number() over () as row_number
from dialog
order by (finished, started);
```

Рассмотрим следующий запрос:

```sql
select *
from dialog
where finished <= '2022-09-07 14:51'
  and started >= '2022-09-07 14:28:00';
```
Тут нет повторяющихся значений в столбце finished, соответственно
после того, как все строки с указанным временем finished найдутся,
среди них строки с указанным started будут искаться полным перебором.
