## Триггеры

Рассмотрим следующую базу данных ([из примера с материализованным представлением](https://gitlab.com/golodnyuk.iv/db_2022/-/blob/main/%D0%9C%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D1%8B%20%D0%BF%D0%BE%20%D0%BA%D1%83%D1%80%D1%81%D1%83/14.%20%D0%9C%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5%20%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%B8%20%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D1%8B.md)):

```sql
drop table if exists tour, review cascade;

create table tour
(
    name       text primary key,
    duration   int,
    start_date date,
    price      decimal
);

insert into tour
values ('Столицы и замки Беларуси', 8, '09-22-2022', 34271),
       ('Сокровища Селигера', 7, '09-23-2022', 38705);

create table review
(
    id        int generated always as identity primary key,
    tour_name text references tour,
    comment   text,
    score     int
);

insert into review (tour_name, comment, score)
values ('Столицы и замки Беларуси', 'Не очень.', 3),
       ('Столицы и замки Беларуси', 'Супер!', 5),
       ('Сокровища Селигера', 'Пойдёт.', 4);

create materialized view tour_with_reviews as
select *
from tour t
         join review r on t.name = r.tour_name;

drop index if exists tour_with_reviews_id;
create unique index tour_with_reviews_id on tour_with_reviews (tour_name, id);
```

Мы можем использовать триггеры для обновления материализованного представления.
Пример создания триггера на обновление таблицы отзывов:

```sql
drop function if exists refresh_tours_with_reviews;
create function refresh_tours_with_reviews()
    returns trigger as
$$
begin
    refresh materialized view concurrently tour_with_reviews;

    return new;
end;
$$
    language 'plpgsql';

create trigger update_review_table
    after insert or update or delete
    on review
    for each row
execute function refresh_tours_with_reviews();
```

Теперь при вставке/обновлении/удалении данных материализованное представление
так же будет обновляться:

```sql
insert into review (tour_name, comment, score)
values ('Сокровища Селигера', 'Не понравилось!', 2);

select *
from tour_with_reviews;
```

## Cron

Cron не входит в стандартный образ postgresql, его нужно ставить отдельно. 
В нашем случае нужно дополнить docker-image. 
Для этого создаем файл с названием `dockerfile-pg` и следующим содержимым: 
```dockerfile
FROM postgres:14.5

RUN apt-get update && apt-get -y install postgresql-14-cron
RUN echo "shared_preload_libraries = 'pg_cron'" >> /usr/share/postgresql/postgresql.conf.sample
```

В `docker-compose.yml` у сервиса `postgres` меняем поле `image: postgres:14.3` на 
```yaml
    build:
      context: .
      dockerfile: ./dockerfile-pg
```

Должно получиться так:
```yaml
  postgres:
    container_name: ${APP_NAME}-postgres
    build:
      context: .
      dockerfile: ./dockerfile-pg
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    user: postgres
    ports:
      - "${POSTGRES_PORT}:5432"
    extra_hosts:
      - "host.docker.internal:host-gateway"
    healthcheck:
      test: ["CMD", "pg_isready"]
      interval: 1s
      timeout: 1s
      retries: 30
    restart: unless-stopped
```

После этого нужно активировать расширение и можно планировать задачи:

```sql
create extension pg_cron;

-- refresh представления каждую минуту:
select cron.schedule('refresh_tours_with_reviews', '* * * * *',
                     $$ refresh materialized view concurrently tour_with_reviews $$);

-- удаление задачи:
select cron.unschedule('refresh_tours_with_reviews');
```
